#region Usings
using System;
using System.Data;
using System.Linq.Expressions;
using System.Reflection;

#endregion

namespace Dapper.Neat.Mapper
{
    public interface IStructureMapItem
    {
        void Compile();
        bool AutoGenerated { get; set; }
        string DestinationName { get; set; }
        bool IsAssignable { get; }
        Type ResultType { get; }
        string SourceName { get; }
        MemberInfo SourceMemberInfo { get; }
        MemberInfo DestinationMemberInfo { get; }
    }


    public interface IStructureMapItem<in TSource> : IStructureMapItem
    {
        
        TPropertyResult GetValue<TPropertyResult>(TSource Data);
        object GetValueForDapperParameters(TSource Data);
        void SetValueFromParameter(TSource Data, DynamicParameters dapperParameters);
    }

    public interface IStructureMapItem<in TSource, TDestination> : IStructureMapItem<TSource>
    {
    }

    public class StructureMapItem<TSource, TDestination, TResult> : IStructureMapItem<TSource, TDestination>
    {
        public StructureMapItem(Expression<Func<TSource, TResult>> sourceExpression, Expression<Func<TDestination, TResult>> destinationExpression)
        {
            SourceExpression = sourceExpression;
            DestinationExpression = destinationExpression;
            Compile();
        }

        public bool AutoGenerated { get; set; }

        public string DestinationName { get; set; }

        public bool IsAssignable
        {
            get { return PropertySetter != null; }
        }

        public Type ResultType
        {
            get { return typeof (TResult); }
        }

        public string SourceName { get; private set; }

        public MemberInfo SourceMemberInfo { get; private set; }

        public MemberInfo DestinationMemberInfo { get; private set; }

        public void Compile()
        {
            CompileGetter();
            CompileSetter();
            if (IsAssignable)
            {
                SourceMemberInfo = (SourceExpression.Body as MemberExpression).Member;
                SourceName = SourceMemberInfo.Name;
            }
            DestinationMemberInfo = ExpressionHelper.GetMemberInfo(DestinationExpression.Body);
            if (DestinationMemberInfo == null)
                throw new InvalidExpressionException("Destination expression doesn't provide clear member access!");
            DestinationName = DestinationMemberInfo.Name;
            AutoGenerated = true;
        }

        public TPropertyResult GetValue<TPropertyResult>(TSource Data)
        {
            return (TPropertyResult) GetValueForDapperParameters(Data);
        }

        public object GetValueForDapperParameters(TSource Data)
        {
            return PropertyGetter(Data);
        }

        public void SetValueFromParameter(TSource Data, DynamicParameters dapperParameters)
        {
            PropertySetter(Data, dapperParameters.Get<TResult>(DestinationName));
        }

        private void CompileGetter()
        {
            PropertyGetter = SourceExpression.Compile();
        }

        private void CompileSetter()
        {
            Expression sourceItemExpression = SourceExpression.Body;
            if (sourceItemExpression.NodeType != ExpressionType.MemberAccess)
                return;
            var valueParameter = Expression.Parameter(typeof (TResult), "value");
            var assignment = Expression.Assign(sourceItemExpression, valueParameter);
            var assignmentExpression = Expression.Lambda<Action<TSource, TResult>>(assignment, SourceExpression.Parameters[0], valueParameter);

            PropertySetter = assignmentExpression.Compile();
        }

        public Expression<Func<TDestination, TResult>> DestinationExpression { get; set; }
        public Func<TSource, TResult> PropertyGetter { get; set; }
        public Action<TSource, TResult> PropertySetter { get; set; }

        public bool Readonly { get; set; }
        public Expression<Func<TSource, TResult>> SourceExpression { get; set; }
    }
}