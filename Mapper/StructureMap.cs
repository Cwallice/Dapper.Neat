#region Usings

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;

#endregion

namespace Dapper.Neat.Mapper
{
    public interface IStructureMap
    {
        #region Abstract Methods

        void CallCompile();
        string GetColumns(string alias);
        string GetDestinationPropertyName(string sourcePropertyName);

        #endregion

        #region Properties (public)

        string DeleteSqlTemplate { get; }
        Type DestinationType { get; }
        Type IdPropertyType { get; }
        string InsertSqlTemplate { get; }
        Type SourceType { get; }
        string TableName { get; }
        string UpdateSqlTemplate { get; }
        IPropertyDescriptor GetPropertyItem(string name);
        List<IPropertyDescriptor> GetPropertyItems();
        bool MapExtraColumns { get; set; }
        #endregion
    }

    public interface IStructureMap<T> : IStructureMap
    {
        #region Abstract Methods

        DynamicParameters GetParameters(T Data, bool isInsert = true);
        string GetPropertyName<TResult>(Expression<Func<T, TResult>> expression);
        void UpdateIdFromParameters(T Data, DynamicParameters parameters);
        DynamicParameters GetIdParameters(T Data);

        #endregion
    }

    public class StructureMap<TSource, TDestination> : IStructureMap<TSource>
    {
        #region Constants

        private const int SQL_MAX_LENGTH = 3000;

        #endregion

        #region Fields (private)

        private readonly List<IPropertyDescriptor<TSource, TDestination>> structureMapList =
            new List<IPropertyDescriptor<TSource, TDestination>>();

        private IPropertyDescriptor<TSource, TDestination> idStructureMap;

        #endregion

        #region IStructureMap<TSource> Properties

        public string DeleteSqlTemplate { get; private set; }

        public Type DestinationType
        {
            get { return typeof (TDestination); }
        }

        public Type IdPropertyType
        {
            get { return idStructureMap != null ? idStructureMap.ResultType : null; }
        }

        public string InsertSqlTemplate { get; private set; }

        public Type SourceType
        {
            get { return typeof (TSource); }
        }

        public string TableName { get; private set; }

        public string UpdateSqlTemplate { get; private set; }

        IPropertyDescriptor IStructureMap.GetPropertyItem(string name)
        {
            return GetPropertyItem(name);
        }

        public List<IPropertyDescriptor> GetPropertyItems()
        {
            var items = structureMapList.Select(si => si as IPropertyDescriptor).ToList();
            if (idStructureMap != null)
                items.Add(idStructureMap);
            return items;
        }

        #endregion

        #region IStructureMap<TSource> Methods

        public void CallCompile()
        {
            Compile();
        }

        public string GetColumns(string alias)
        {
            var totalList = idStructureMap != null 
                ? (new List<IPropertyDescriptor<TSource, TDestination>> { idStructureMap }).Union(structureMapList)
                : structureMapList;
            return String.Join(",",
                totalList.Select(x => FormatColumn(alias,x.DestinationName,x.SourceName)));
        }

        private string FormatColumn(string alias, string destination, string source)
        {
            if (LeanMapper.UserDapperRegistration)
            {
                return String.Format("{0}.[{1}]", alias, destination);
            }
            return String.Format("{0}.[{1}] as {2}", alias, destination, source);

        }

        public DynamicParameters GetParameters(TSource Data, bool isInsert = true)
        {
            DynamicParameters parameters = new DynamicParameters();
            foreach (var item in structureMapList)
            {
                parameters.Add(item.DestinationName, item.GetValueForDapperParameters(Data));
            }
            if (idStructureMap != null && idStructureMap.IsAssignable)
                parameters.Add(idStructureMap.DestinationName, idStructureMap.GetValueForDapperParameters(Data), null,
                    isInsert && idStructureMap.AutoGenerated ? ParameterDirection.Output : ParameterDirection.Input);
            return parameters;
        }

        public DynamicParameters GetIdParameters(TSource Data)
        {
            DynamicParameters parameters = new DynamicParameters();
            if (idStructureMap != null && idStructureMap.IsAssignable)
                parameters.Add(idStructureMap.DestinationName, idStructureMap.GetValueForDapperParameters(Data));
            return parameters;
        }

        public string GetPropertyName<TResult>(Expression<Func<TSource, TResult>> expression)
        {
            return GetPropertyItem(ExpressionHelper.GetPropertyName(expression)).DestinationName;
        }

        public string GetDestinationPropertyName(string sourcePropertyName)
        {
            return GetPropertyItem(sourcePropertyName).DestinationName;
        }

        public void UpdateIdFromParameters(TSource Data, DynamicParameters parameters)
        {
            if (idStructureMap != null)
                idStructureMap.SetValueFromParameter(Data, parameters);
        }

        #endregion

        #region Methods (public)

        public void AutoMap()
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.Instance;
            var mInfo =
                typeof (StructureMap<TSource, TDestination>).GetMethods()
                    .FirstOrDefault(m => m.Name == "MapProperty" && m.GetParameters().Length == 2);
            var properties = (from sp in typeof (TSource).GetProperties(flags)
                join dp in typeof (TDestination).GetProperties(flags) on sp.Name.ToUpper() equals dp.Name.ToUpper()
                where
                    sp.PropertyType == dp.PropertyType
                    && sp.CanWrite
                    && sp.CanRead
                    && dp.CanWrite
                    && dp.CanRead
                    && (sp.PropertyType == typeof (string) || !typeof (IEnumerable).IsAssignableFrom(sp.PropertyType))
                select new {SourceProperty = sp, DestinationProperty = dp}).ToList();

            foreach (var property in properties)
            {
                AddPropertyExpressionToMap(mInfo, property.SourceProperty, property.DestinationProperty);
            }
        }

        public StructureMap<TSource, TDestination> Compile()
        {
            //build sql template statements
            if (String.IsNullOrWhiteSpace(TableName))
                TableName = typeof (TDestination).Name;
            BuildInsertExpression();
            BuildUpdateExpression();
            BuildSelectExpression();
            BuildDeleteExpression();
            return this;
        }

        public IPropertyDescriptor<TSource, TDestination> GetIdPropertyItem()
        {
            return idStructureMap;
        }

        public IPropertyDescriptor<TSource, TDestination> GetPropertyItem(string name)
        {
            return (structureMapList.FirstOrDefault(sm => sm.SourceName == name)) ??
                   (idStructureMap.SourceName == name ? idStructureMap : null);
        }

        public PropertyDescriptor<TSource, TDestination, TResult> MapIdProperty<TResult>(
            Expression<Func<TSource, TResult>> sourceExpression,
            Expression<Func<TDestination, TResult>> destinationExpression = null)
        {
            destinationExpression = destinationExpression ?? sourceExpression as Expression<Func<TDestination, TResult>>;
            var idMapping = new PropertyDescriptor<TSource, TDestination, TResult>(sourceExpression, destinationExpression);
            idStructureMap = idMapping;
            return idMapping;
        }

        public PropertyDescriptor<TSource, TDestination, TResult> MapProperty<TResult>(
            Expression<Func<TSource, TResult>> sourceExpression,
            Expression<Func<TDestination, TResult>> destinationExpression = null)
        {
            destinationExpression = destinationExpression ?? sourceExpression as Expression<Func<TDestination, TResult>>;
            var newStructureMap = new PropertyDescriptor<TSource, TDestination, TResult>(sourceExpression,
                destinationExpression);
            if (idStructureMap != null && (newStructureMap.SourceName == idStructureMap.SourceName || newStructureMap.DestinationName == idStructureMap.DestinationName))
                return newStructureMap;
            structureMapList.Add(newStructureMap);
            return newStructureMap;
        }

        public StructureMap<TSource, TDestination> SetTable(string tableName)
        {
            TableName = tableName;
            return this;
        }

        public void Unmap<TResult>(Expression<Func<TSource, TResult>> sourceExpression)
        {
            string propertyName = ExpressionHelper.GetPropertyName(sourceExpression.Body);
            if (idStructureMap != null && idStructureMap.SourceName == propertyName)
                idStructureMap = null;
            var structureMap = structureMapList.FirstOrDefault(m => m.SourceName == propertyName);
            if (structureMap != null)
                structureMapList.Remove(structureMap);
        }

        #endregion

        #region Methods (private)

        private void AddPropertyExpressionToMap(MethodInfo mapPropertyMethod, PropertyInfo sourcePropertyInfo,
            PropertyInfo destinationPropertyInfo)
        {
            var genericMethod = mapPropertyMethod.MakeGenericMethod(destinationPropertyInfo.PropertyType);
            var inputParam = Expression.Parameter(typeof (StructureMap<TSource, TDestination>));
            var sourceExpressionValue = ExpressionHelper.GetPropertyExpression(sourcePropertyInfo);
            var destinationExpressionValue = ExpressionHelper.GetPropertyExpression(destinationPropertyInfo);

            var block = Expression.Block(inputParam,
                Expression.Call(inputParam, genericMethod, sourceExpressionValue, destinationExpressionValue));
            Expression.Lambda<Action<StructureMap<TSource, TDestination>>>(block, inputParam).Compile()(this);
        }

        private void BuildDeleteExpression()
        {
            if (idStructureMap == null)
                return;
            DeleteSqlTemplate = String.Format("Delete from [{0}] where [{1}] = @{1}", TableName,
                idStructureMap.DestinationName);
        }

        private void BuildInsertExpression()
        {
            StringBuilder insertSqlExpressionBuilder = new StringBuilder(SQL_MAX_LENGTH);
            insertSqlExpressionBuilder.AppendLine(String.Format("INSERT INTO [{0}] ", TableName));
            string columnNames = String.Join(",",
                structureMapList.Select(x => String.Format("[{0}]", x.DestinationName)));
            string valueParams = String.Join(",", structureMapList.Select(x => String.Format("@{0}", x.DestinationName)));
            if (idStructureMap != null && idStructureMap.IsAssignable && !idStructureMap.AutoGenerated)
            {
                columnNames = columnNames + String.Format(",[{0}]", idStructureMap.DestinationName);
                valueParams = valueParams + String.Format(",@{0}", idStructureMap.DestinationName);
            }
            insertSqlExpressionBuilder.AppendLine(String.Format("({0})", columnNames));
            insertSqlExpressionBuilder.AppendLine(String.Format("VALUES ({0});", valueParams));
            if (idStructureMap != null && idStructureMap.IsAssignable && idStructureMap.AutoGenerated)
                insertSqlExpressionBuilder.AppendLine(String.Format("Select @{0} = SCOPE_IDENTITY();",
                    idStructureMap.DestinationName));
            InsertSqlTemplate = insertSqlExpressionBuilder.ToString();
        }

        private void BuildSelectExpression()
        {
            if (idStructureMap == null)
                return;
            StringBuilder sqlExpressionBuilder = new StringBuilder(SQL_MAX_LENGTH);
            SelectColumnNames = GetColumns(TableName);
            sqlExpressionBuilder.AppendLine(String.Format("Select {0} from [{1}] ", SelectColumnNames, TableName));
            sqlExpressionBuilder.AppendLine(String.Format("Where {0} = @{0};", idStructureMap.DestinationName));
            SelectSqlTemplate = sqlExpressionBuilder.ToString();
        }

        private void BuildUpdateExpression()
        {
            if (idStructureMap == null)
                return;
            StringBuilder sqlExpressionBuilder = new StringBuilder(SQL_MAX_LENGTH);
            sqlExpressionBuilder.AppendLine(String.Format("UPDATE [{0}] ", TableName));
            string columnNames = String.Join(",",
                structureMapList.Select(x => String.Format("[{0}] = @{0}", x.DestinationName)));
            sqlExpressionBuilder.AppendLine(String.Format("Set {0}", columnNames));
            sqlExpressionBuilder.AppendLine(String.Format("Where {0} = @{0}", idStructureMap.DestinationName));
            UpdateSqlTemplate = sqlExpressionBuilder.ToString();
        }

        #endregion

        #region Properties (public)

        public string SelectColumnNames { get; private set; }
        public string SelectSqlTemplate { get; private set; }

        #endregion


        public bool MapExtraColumns { get; set; }
    }
}