#region Usings

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;

#endregion

namespace Dapper.Neat.Mapper
{
    public interface IStructureMap
    {
        string DeleteSqlTemplate { get; }
        Type DestinationType { get; }
        Type IdPropertyType { get; }
        string InsertSqlTemplate { get; }
        Type SourceType { get; }
        string TableName { get; }
        string UpdateSqlTemplate { get; }
        void CallCompile();
        string GetColumns(string alias);
        string GetPropertyName(string sourcePropertyName);
    }

    public interface IStructureMap<T> : IStructureMap
    {
        DynamicParameters GetParameters(T Data, bool isInsert = true);
        string GetPropertyName<TResult>(Expression<Func<T, TResult>> expression);
        void UpdateIdFromParameters(T Data, DynamicParameters parameters);
        DynamicParameters GetIdParameters(T Data);
    }

    public class StructureMap<TSource, TDestination> : IStructureMap<TSource>
    {
        private const int SQL_MAX_LENGTH = 3000;

        private readonly List<IStructureMapItem<TSource, TDestination>> structureMapList =
            new List<IStructureMapItem<TSource, TDestination>>();

        private IStructureMapItem<TSource, TDestination> idStructureMap;

        public string SelectColumnNames { get; private set; }
        public string SelectSqlTemplate { get; private set; }

        public string DeleteSqlTemplate { get; private set; }

        public Type DestinationType
        {
            get { return typeof(TDestination); }
        }

        public Type IdPropertyType
        {
            get { return idStructureMap != null ? idStructureMap.ResultType : null; }
        }

        public string InsertSqlTemplate { get; private set; }

        public Type SourceType
        {
            get { return typeof(TSource); }
        }

        public string TableName { get; private set; }

        public string UpdateSqlTemplate { get; private set; }

        public void CallCompile()
        {
            Compile();
        }

        public string GetColumns(string alias)
        {
            var totalList = new List<IStructureMapItem<TSource, TDestination>> {idStructureMap}.Union(structureMapList);
            return string.Join(",",
                totalList.Select(x => $"{alias}.[{x.DestinationName}] as {x.SourceName}"));
        }

        public DynamicParameters GetParameters(TSource Data, bool isInsert = true)
        {
            var parameters = new DynamicParameters();
            foreach (var item in structureMapList)
            {
                parameters.Add(item.DestinationName, item.GetValueForDapperParameters(Data));
            }
            if (idStructureMap != null && idStructureMap.IsAssignable)
                parameters.Add(idStructureMap.DestinationName, idStructureMap.GetValueForDapperParameters(Data), null,
                    isInsert && idStructureMap.AutoGenerated ? ParameterDirection.Output : ParameterDirection.Input);
            return parameters;
        }

        public DynamicParameters GetIdParameters(TSource Data)
        {
            var parameters = new DynamicParameters();
            if (idStructureMap != null && idStructureMap.IsAssignable)
                parameters.Add(idStructureMap.DestinationName, idStructureMap.GetValueForDapperParameters(Data));
            return parameters;
        }

        public string GetPropertyName<TResult>(Expression<Func<TSource, TResult>> expression)
        {
            return GetPropertyItem(ExpressionHelper.GetPropertyName(expression)).DestinationName;
        }

        public string GetPropertyName(string sourcePropertyName)
        {
            return GetPropertyItem(sourcePropertyName).DestinationName;
        }

        public void UpdateIdFromParameters(TSource Data, DynamicParameters parameters)
        {
            if (idStructureMap != null)
                idStructureMap.SetValueFromParameter(Data, parameters);
        }

        public void AutoMap()
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.Instance;
            var mInfo =
                typeof(StructureMap<TSource, TDestination>).GetMethods()
                    .FirstOrDefault(m => m.Name == "MapProperty" && m.GetParameters().Length == 2);
            var properties = (from sp in typeof(TSource).GetProperties(flags)
                join dp in typeof(TDestination).GetProperties(flags) on sp.Name equals dp.Name
                where
                    sp.PropertyType == dp.PropertyType
                    && sp.CanWrite
                    && sp.CanRead
                    && dp.CanWrite
                    && dp.CanRead
                    && (sp.PropertyType == typeof(string) || !typeof(IEnumerable).IsAssignableFrom(sp.PropertyType))
                select new {SourceProperty = sp, DestinationProperty = dp}).ToList();

            foreach (var property in properties)
            {
                AddPropertyExpressionToMap(mInfo, property.SourceProperty, property.DestinationProperty);
            }
        }

        public StructureMap<TSource, TDestination> Compile()
        {
            //build sql template statements
            if (string.IsNullOrWhiteSpace(TableName))
                TableName = typeof(TDestination).Name;
            BuildInsertExpression();
            BuildUpdateExpression();
            BuildSelectExpression();
            BuildDeleteExpression();
            return this;
        }

        public IStructureMapItem<TSource, TDestination> GetIdPropertyItem()
        {
            return idStructureMap;
        }

        public IStructureMapItem<TSource, TDestination> GetPropertyItem(string name)
        {
            return structureMapList.FirstOrDefault(sm => sm.SourceName == name) ??
                   (idStructureMap.SourceName == name ? idStructureMap : null);
        }

        public StructureMapItem<TSource, TDestination, TResult> MapIdProperty<TResult>(
            Expression<Func<TSource, TResult>> sourceExpression,
            Expression<Func<TDestination, TResult>> destinationExpression = null)
        {
            destinationExpression = destinationExpression ?? sourceExpression as Expression<Func<TDestination, TResult>>;
            var idMapping = new StructureMapItem<TSource, TDestination, TResult>(sourceExpression, destinationExpression);
            idStructureMap = idMapping;
            return idMapping;
        }

        public StructureMapItem<TSource, TDestination, TResult> MapProperty<TResult>(
            Expression<Func<TSource, TResult>> sourceExpression,
            Expression<Func<TDestination, TResult>> destinationExpression = null)
        {
            destinationExpression = destinationExpression ?? sourceExpression as Expression<Func<TDestination, TResult>>;
            var newStructureMap = new StructureMapItem<TSource, TDestination, TResult>(sourceExpression,
                destinationExpression);
            if (idStructureMap != null && newStructureMap.SourceName == idStructureMap.SourceName)
                return newStructureMap;
            structureMapList.Add(newStructureMap);
            return newStructureMap;
        }

        public StructureMap<TSource, TDestination> SetTable(string tableName)
        {
            TableName = tableName;
            return this;
        }

        public void Unmap<TResult>(Expression<Func<TSource, TResult>> sourceExpression)
        {
            var propertyName = ExpressionHelper.GetPropertyName(sourceExpression.Body);
            if (idStructureMap != null && idStructureMap.SourceName == propertyName)
                idStructureMap = null;
            var structureMap = structureMapList.FirstOrDefault(m => m.SourceName == propertyName);
            if (structureMap != null)
                structureMapList.Remove(structureMap);
        }

        private void AddPropertyExpressionToMap(MethodInfo mapPropertyMethod, PropertyInfo sourcePropertyInfo,
            PropertyInfo destinationPropertyInfo)
        {
            var genericMethod = mapPropertyMethod.MakeGenericMethod(destinationPropertyInfo.PropertyType);
            var inputParam = Expression.Parameter(typeof(StructureMap<TSource, TDestination>));
            var sourceExpressionValue = ExpressionHelper.GetPropertyExpression(sourcePropertyInfo);
            var destinationExpressionValue = ExpressionHelper.GetPropertyExpression(destinationPropertyInfo);

            var block = Expression.Block(inputParam,
                Expression.Call(inputParam, genericMethod, sourceExpressionValue, destinationExpressionValue));
            Expression.Lambda<Action<StructureMap<TSource, TDestination>>>(block, inputParam).Compile()(this);
        }

        private void BuildDeleteExpression()
        {
            if (idStructureMap == null)
                return;
            DeleteSqlTemplate = string.Format("Delete from [{0}] where [{1}] = @{1}", TableName,
                idStructureMap.DestinationName);
        }

        private void BuildInsertExpression()
        {
            var insertSqlExpressionBuilder = new StringBuilder(SQL_MAX_LENGTH);
            insertSqlExpressionBuilder.AppendLine(string.Format("INSERT INTO [{0}] ", TableName));
            var columnNames = string.Join(",", structureMapList.Select(x => string.Format("[{0}]", x.DestinationName)));
            var valueParams = string.Join(",", structureMapList.Select(x => string.Format("@{0}", x.DestinationName)));
            if (idStructureMap != null && idStructureMap.IsAssignable && !idStructureMap.AutoGenerated)
            {
                columnNames = columnNames + string.Format(",[{0}]", idStructureMap.DestinationName);
                valueParams = valueParams + string.Format(",@{0}", idStructureMap.DestinationName);
            }
            insertSqlExpressionBuilder.AppendLine(string.Format("({0})", columnNames));
            insertSqlExpressionBuilder.AppendLine(string.Format("VALUES ({0});", valueParams));
            if (idStructureMap != null && idStructureMap.IsAssignable && idStructureMap.AutoGenerated)
                insertSqlExpressionBuilder.AppendLine(string.Format("Select @{0} = SCOPE_IDData();",
                    idStructureMap.DestinationName));
            InsertSqlTemplate = insertSqlExpressionBuilder.ToString();
        }

        private void BuildSelectExpression()
        {
            if (idStructureMap == null)
                return;
            var sqlExpressionBuilder = new StringBuilder(SQL_MAX_LENGTH);
            SelectColumnNames = GetColumns(TableName);
            sqlExpressionBuilder.AppendLine(string.Format("Select {0} from [{1}] ", SelectColumnNames, TableName));
            sqlExpressionBuilder.AppendLine(string.Format("Where {0} = @{0};", idStructureMap.DestinationName));
            SelectSqlTemplate = sqlExpressionBuilder.ToString();
        }

        private void BuildUpdateExpression()
        {
            if (idStructureMap == null)
                return;
            var sqlExpressionBuilder = new StringBuilder(SQL_MAX_LENGTH);
            sqlExpressionBuilder.AppendLine(string.Format("UPDATE [{0}] ", TableName));
            var columnNames = string.Join(",",
                structureMapList.Select(x => string.Format("[{0}] = @{0}", x.DestinationName)));
            sqlExpressionBuilder.AppendLine(string.Format("Set {0}", columnNames));
            sqlExpressionBuilder.AppendLine(string.Format("Where {0} = @{0}", idStructureMap.DestinationName));
            UpdateSqlTemplate = sqlExpressionBuilder.ToString();
        }
    }
}